from __future__ import annotations

from pathlib import Path
import re
from urllib.parse import unquote


REPO_ROOT = Path(__file__).resolve().parents[1]

LLMS_MANIFEST_PATH = REPO_ROOT / "llms.txt"
LLMS_FULL_PATH = REPO_ROOT / "llms-full.txt"

_MARKDOWN_LINK_RE = re.compile(r"\[[^\]]+\]\(([^)]+)\)")


def _dedup_preserve_order(values: list[str]) -> list[str]:
    seen: set[str] = set()
    out: list[str] = []
    for v in values:
        if not v or v in seen:
            continue
        seen.add(v)
        out.append(v)
    return out


def _is_external_link(target: str) -> bool:
    t = target.strip().lower()
    return t.startswith(("http://", "https://", "mailto:"))


def _extract_repo_paths_from_llms_txt(text: str) -> list[str]:
    paths: list[str] = []
    for match in _MARKDOWN_LINK_RE.finditer(text):
        target = match.group(1).strip()
        if not target or _is_external_link(target):
            continue

        # Drop query/fragment to get a stable filesystem path.
        target = target.split("#", 1)[0].split("?", 1)[0].strip()
        if not target:
            continue

        # Normalize to repo-relative.
        if target.startswith("/"):
            target = target.lstrip("/")
        target = unquote(target)

        # Avoid self-recursion.
        if target == "llms-full.txt":
            continue

        paths.append(target)

    return _dedup_preserve_order(paths)

LANG_BY_SUFFIX = {
    ".py": "python",
    ".yaml": "yaml",
    ".yml": "yaml",
    ".toml": "toml",
}


def _render_file(path: Path) -> str:
    rel = path.relative_to(REPO_ROOT).as_posix()
    content = path.read_text(encoding="utf-8").rstrip() + "\n"

    lang = LANG_BY_SUFFIX.get(path.suffix)
    if lang:
        return f"## {rel}\n\n```{lang}\n{content}```\n"
    return f"## {rel}\n\n{content}\n"


def main() -> None:
    manifest_text = LLMS_MANIFEST_PATH.read_text(encoding="utf-8")
    files_in_order = _dedup_preserve_order(["llms.txt"] + _extract_repo_paths_from_llms_txt(manifest_text))

    missing = [p for p in files_in_order if not (REPO_ROOT / p).exists()]
    if missing:
        raise SystemExit(f"Missing files: {', '.join(missing)}")

    included_list = "\n".join([f"- `{p}`" for p in files_in_order])
    parts: list[str] = [
        "# abstractsemantics (full context)\n",
        "> Single-file, LLM-friendly snapshot generated from `llms.txt`. It embeds the contents of all repository-local links in the manifest (including `## Optional`), excluding `llms-full.txt` itself.\n\n",
        "Generated by `scripts/generate_llms_full.py` from `llms.txt`. Do not edit this file manually.\n\n",
        "Included files, in order:\n",
        f"{included_list}\n\n",
    ]

    for rel in files_in_order:
        parts.append("---\n\n")
        parts.append(_render_file(REPO_ROOT / rel))

    out = "".join(parts).rstrip() + "\n"
    LLMS_FULL_PATH.write_text(out, encoding="utf-8")


if __name__ == "__main__":
    main()
